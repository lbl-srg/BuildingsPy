<html>
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
    <title>$PAGE_TITLE</title>
    <script src="https://cdn.plot.ly/plotly-3.0.1.min.js" charset="utf-8"></script>
  </head>

  <body>
    <div id="myDiv" style="height: $HEIGHT; width: 100%" class="plotly-graph-div"></div>
    <script>
      // Simple CSV loading function similar to plot_bck.html
      function loadCSV(url) {
        return fetch(url)
          .then((response) => {
            if (!response.ok) {
              throw new Error(`Failed to load ${url}: ${response.status} ${response.statusText}`);
            }
            return response.text();
          })
          .then((text) => {
            // Simple CSV parsing
            const lines = text.split("\n");
            const headers = lines[0].split(",");
            const result = [];

            for (let i = 1; i < lines.length; i++) {
              if (!lines[i].trim()) continue;
              const values = lines[i].split(",");
              const row = {};

              headers.forEach((header, j) => {
                row[header.trim()] = values[j] ? values[j].trim() : "";
              });

              result.push(row);
            }
            return result;
          });
      }

      async function makePlot() {
        try {
          const srv_url = "http://localhost:$SERVER_PORT";
          const dict_var_info = $DICT_VAR_INFO;
          const dict_data = {};
          const avail_groups = [];

          // Show loading indicator
          document.getElementById("myDiv").innerHTML = '<div style="text-align:center;padding-top:100px;">Loading data...</div>';

          // Simple server accessibility check
          const serverResponse = await fetch(srv_url);
          if (!serverResponse.ok) {
            throw new Error(`Server not accessible (status: ${serverResponse.status})`);
          }

          // Collect all groups and load data sequentially to avoid overwhelming the server
          const variables = Object.keys(dict_var_info);
          
          for (const v of variables) {
            dict_var_info[v].forEach((el) => {
              avail_groups.push(el["group"]);
            });

            try {
              // Load files for this variable sequentially
              const fileDir = dict_var_info[v][0]["dir"];
              const baseUrl = [srv_url, fileDir].join("/");
              
              console.log(`Loading data for variable: ${v} from ${baseUrl}`);
              
              const [refData, testData, errData] = await Promise.all([
                loadCSV(`${baseUrl}/reference.csv`),
                loadCSV(`${baseUrl}/test.csv`),
                loadCSV(`${baseUrl}/errors.csv`)
              ]);

              dict_data[v] = {
                ref: processData(refData),
                test: processData(testData),
                err: processData(errData),
              };

            } catch (error) {
              console.warn(`Failed to load data for variable ${v}: ${error.message}`);
              // Continue with other variables instead of failing completely
            }
          }

          console.log("DATA LOADING COMPLETED");
          
          // Check if we have any data to plot
          if (Object.keys(dict_data).length === 0) {
            throw new Error("No data could be loaded for any variables");
          }

          // Plot the data
          plot(dict_data, dict_var_info, avail_groups);
          
        } catch (error) {
          console.error("Error loading or processing data:", error);
          let errorMessage = error.message;
          let suggestions = "";
          
          if (error.message.includes("Server not accessible") || 
              error.message.includes("Failed to fetch") || 
              error.message.includes("ERR_CONNECTION_REFUSED")) {
            suggestions = `<br><br><strong>Possible solutions:</strong><ul style="text-align:left;display:inline-block;">
              <li>Check if the funnel server is running</li>
              <li>Try running: <code>python -c "import buildingspy.development.regressiontest as t; t.Tester().report()"</code></li>
              <li>Ensure all required CSV data files exist in the funnel_comp directory</li>
              </ul>`;
          }
          
          document.getElementById("myDiv").innerHTML = `<div style="text-align:center;padding:20px;color:red;">
                        <strong>Error loading data:</strong> ${errorMessage}${suggestions}<br><br>
                        <button onclick="makePlot()" style="padding:10px 20px;">Retry</button>
                    </div>`;
        }
      }

      function processData(allRows) {
        const x = [], y = [];
        for (let i = 0; i < allRows.length; i++) {
          const row = allRows[i];
          x.push(row["x"]);
          y.push(row["y"]);
        }
        return { x: x, y: y };
      }

      function plot(dict_data, dict_var_info, avail_groups) {
        // Group variables by their groups
        const uniq_groups = [...new Set(avail_groups)];
        const flag_groups = [];
        const list_group_var = new Array(uniq_groups.length);

        Object.keys(dict_var_info).forEach((v) => {
          // Only process variables that have data
          if (!dict_data[v]) return;
          
          dict_var_info[v].forEach((el) => {
            let group_reset = flag_groups.indexOf(el["group"]);
            if (group_reset == -1) {
              group_reset = flag_groups.push(el["group"]) - 1;
            }
            (list_group_var[group_reset] = list_group_var[group_reset] || []).push(v);
          });
        });

        var nb_groups = list_group_var.filter(group => group && group.length > 0).length;
        
        // Define color palette
        var colorPalette = [
          "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
          "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
        ];
        var getColor = function (i) {
          return colorPalette[i % colorPalette.length];
        };

        var traces = [];
        var axis_error_idx = 1;
        var error_y_axis_title = "error [unit of variable]";
        var gen_y_axis_title = "variable";
        var gen_x_axis_title = "time [s]";
        var tickformatstops = [
          { dtickrange: [0, 0.1], value: ".2e" },
          { dtickrange: [0.1, 1000], value: ".1f" },
          { dtickrange: [1000, null], value: ".2e" },
        ];

        // Dummy traces for legend
        traces.push(
          {
            x: [null], y: [null], legendgroup: 99, showlegend: true,
            name: "Errors (in upper plot)", mode: "lines",
            line: { color: "rgb(211,211,211)" },
            xaxis: "x" + axis_error_idx, yaxis: "y" + axis_error_idx,
          },
          {
            x: [null], y: [null], legendgroup: 99, showlegend: true,
            name: "Reference data", mode: "lines",
            line: { dash: "dot", color: "rgb(211,211,211)" },
            xaxis: "x" + axis_error_idx, yaxis: "y" + axis_error_idx,
          },
          {
            x: [null], y: [null], legendgroup: 99, showlegend: true,
            name: "Test data", mode: "lines",
            line: { color: "rgb(211,211,211)" },
            xaxis: "x" + axis_error_idx, yaxis: "y" + axis_error_idx,
          },
        );

        // Layout
        var layout = {
          title: { text: "$TITLE" },
          grid: { rows: nb_groups + 1, columns: 1 },
          legend: { x: 1.02, y: 1 },
        };

        // Error domain
        var err_plot_height = $ERR_PLOT_HEIGHT;
        layout["yaxis" + axis_error_idx] = {
          domain: [1 - err_plot_height, 1],
          ticks: "inside", tickformatstops: tickformatstops,
          showline: true, zeroline: true, title: error_y_axis_title,
        };
        layout["xaxis" + axis_error_idx] = {
          showline: false, zeroline: false, tickformatstops: tickformatstops,
          showticklabels: false, anchor: "y" + axis_error_idx,
        };

        // Calculate domains for data plots
        var divHeight = parseFloat(document.getElementById("myDiv").style.height) || 600;
        var spacing = (0.02 * 100) / divHeight;
        var t_offset = err_plot_height + 2 * spacing;

        // Data traces and axes
        var i = -1;
        list_group_var.forEach(function (el, group) {
          if (!el || el.length === 0) return;
          
          el.forEach(function (v, idv) {
            var data = dict_data[v];
            if (!data || !data.ref || !data.test || !data.err) {
              console.warn(`Skipping variable ${v} due to missing data`);
              return;
            }
            
            i++;
            var axis_data_idx = group + 2; // 1 is for error

            traces.push({
              x: data["ref"].x, y: data["ref"].y,
              legendgroup: v + group, showlegend: false,
              hoverlabel: { namelength: -1 }, name: [v, "ref"].join("_"),
              line: { dash: "dot", color: getColor(i) },
              xaxis: "x" + axis_data_idx, yaxis: "y" + axis_data_idx,
            });
            
            traces.push({
              x: data["test"].x, y: data["test"].y,
              legendgroup: v + group, name: v,
              hoverlabel: { namelength: -1 },
              line: { color: getColor(i) },
              xaxis: "x" + axis_data_idx, yaxis: "y" + axis_data_idx,
            });
            
            traces.push({
              x: data["err"].x, y: data["err"].y,
              legendgroup: v + group, showlegend: false,
              hoverlabel: { namelength: -1 }, name: [v, "error"].join("_"),
              line: { color: getColor(i) },
              xaxis: "x" + axis_error_idx, yaxis: "y" + axis_error_idx,
            });

            layout["yaxis" + axis_data_idx] = {
              domain: getDomain(group, nb_groups, t_offset, 0.0, spacing),
              ticks: "inside", mirror: "ticks", showline: true, zeroline: false,
              title: gen_y_axis_title, tickformatstops: tickformatstops,
            };
            
            layout["xaxis" + axis_data_idx] = {
              ticks: "inside", showline: true, showticklabels: false,
              mirror: "ticks", zeroline: false, anchor: "y" + axis_data_idx,
              matches: "x", tickformatstops: tickformatstops,
            };
          });
        });

        // Configure x-axis labels
        if (nb_groups > 0) {
          layout["xaxis2"]["showticklabels"] = true;
          if (nb_groups > 1) {
            layout["xaxis2"]["side"] = "top";
          } else {
            layout["xaxis2"]["mirror"] = false;
            layout["yaxis2"]["mirror"] = false;
            layout["xaxis1"]["showline"] = true;
            layout["xaxis1"]["showticklabels"] = true;
          }
          layout["xaxis" + (nb_groups + 1)]["showticklabels"] = true;
          layout["xaxis" + (nb_groups + 1)]["title"] = gen_x_axis_title;
        }

        // Create the plot
        Plotly.newPlot("myDiv", traces, layout, { responsive: true })
          .then(function() {
            console.log("Plot rendered successfully");
          })
          .catch(function(error) {
            console.error("Error rendering plot:", error);
            document.getElementById("myDiv").innerHTML = `<div style="color:red;text-align:center;padding-top:100px;">
              Error rendering plot: ${error.message}<br>
              <button onclick="makePlot()">Retry</button>
            </div>`;
          });
      }

      function getDomain(i, n_domain, t_offset = 0.0, b_offset = 0.0, spacing = 0.02) {
        // From top (i = 0) to bottom (i = n_domain-1)
        i = n_domain - i - 1;
        return [
          b_offset + ((1 - b_offset - t_offset) / n_domain) * i + (i === 0 ? 0 : spacing / 2),
          b_offset + ((1 - b_offset - t_offset) / n_domain) * (i + 1) - (i === n_domain - 1 ? 0 : spacing / 2),
        ];
      }

      // Function to check if Plotly is loaded and then make the plot
      function waitForPlotlyAndMakePlot() {
        if (typeof Plotly !== "undefined") {
          makePlot();
        } else {
          setTimeout(waitForPlotlyAndMakePlot, 100);
        }
      }

      // Start the plot process once everything is loaded
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", waitForPlotlyAndMakePlot);
      } else {
        waitForPlotlyAndMakePlot();
      }

      // Reposition legend when scrolling
      let last_known_scroll_position = 0;
      let ticking = false;
      
      function repositionLegend(scroll_pos) {
        var scrollMaxY = Math.max(
          document.body.scrollHeight, document.body.offsetHeight,
          document.documentElement.clientHeight, document.documentElement.scrollHeight,
          document.documentElement.offsetHeight,
        ) - window.innerHeight;
        
        var update = {
          legend: { x: 1.02, y: (scrollMaxY - scroll_pos) / scrollMaxY },
        };
        
        Plotly.relayout("myDiv", update);
      }
      
      window.addEventListener("scroll", function (e) {
        last_known_scroll_position = window.scrollY;
        if (!ticking) {
          window.requestAnimationFrame(function () {
            repositionLegend(last_known_scroll_position);
            ticking = false;
          });
          ticking = true;
        }
      });
    </script>
  </body>
</html>